#!/usr/bin/env ruby

require "tty-cursor"
require "tty-reader"
require "neovim"

TTY::Reader::Console.send(:remove_const, :TIMEOUT)
TTY::Reader::Console.const_set :TIMEOUT, 0.001

class Key
  def initialize(event)
    @event = event
  end

  def kind # rubocop:disable Metrics/MethodLength
    if left_word? then :left_word
    elsif right_word? then :right_word
    elsif backspace_word? then :backspace_word
    elsif delete_word? then :delete_word
    elsif backspace_line? then :backspace_line
    elsif regular_char? then :regular_char
    else
      :unkown
    end
  end

  def left_word?
    ignore? && !ctrl? && !meta? && !shift? && value == "\eb"
  end

  def right_word?
    ignore? && !ctrl? && !meta? && !shift? && value == "\ef"
  end

  def backspace_word?
    ignore? && !ctrl? && !meta? && !shift? && value == "\e\u007F"
  end

  def delete_word?
    ignore? && !ctrl? && !meta? && !shift? && value == "\ed"
  end

  def backspace_line?
    ignore? && !ctrl? && !meta? && !shift? && value == "\ew"
  end

  def regular_char?
    %i(alpha num space).include?(name) || (!ctrl? && !meta? && ignore?)
  end

  private

  attr_reader :event

  def ctrl?   = event.key.ctrl
  def meta?   = event.key.meta
  def shift?  = event.key.shift
  def name    = event.key.name
  def ignore? = event.key.name == :ignore
  def value   = event.value
end

class App
  extend Forwardable

  def_delegators :prompt, :draw, :clear_line, :send_input, :initial_draw

  def self.run
    new.run
  end

  def initialize
    @done = false
    @quit = false
    @reader = TTY::Reader.new(interrupt: :noop)
    @prompt = Prompt.new(self)
  end

  def run
    initial_draw

    reader.subscribe(prompt)
    reader.read_keypress until done?

    clear_line
    send_input unless quit?

    exit 1 if quit?
  end

  def done?
    @done
  end

  def done!
    @done = true
  end

  def quit?
    @quit
  end

  def quit!
    @quit = true
  end

  private

  attr_reader :reader, :prompt
end

class Completions
  def initialize
    @client = Neovim.attach_unix(ARGV[0])
  rescue Errno::ENOENT
    instances = `ls ${XDG_RUNTIME_DIR:-${TMPDIR}nvim.${USER}}/*/nvim.*.0`
    puts "Can't find that instance. Try one of these instead:\n\n#{instances}\n"
    exit 1
  end

  def choices(q)
    return [] if q.empty?

    @choices ||= {}
    @choices[q] ||= client.call_function("getcompletion", [q, "cmdline"])
  end

  private

  attr_reader :client
end

class Prompt
  def initialize(app)
    @input = ""
    @position = 0
    @cursor = TTY::Cursor
    @app = app
    @completions = Completions.new
  end

  attr_accessor :input, :position

  def draw
    clear_line
    print input_line
    clear_and_restore do
      print completions.choices(input).first(max_rows).join("\r\n")
    end
  end

  def initial_draw
    print "\n" * max_rows
    print cursor.up(max_rows + 1)

    draw
  end

  def clear_line
    print cursor.clear_line
  end

  def send_input
    puts input unless input.nil?
  end

  def keyctrl_d(*)
    return unless position != input.size

    input.slice!(position)
    draw
  end

  def keyctrl_u(*)
    self.input = ""
    draw
  end

  def keybackspace(*)
    return if input.empty?

    self.input = input[0...-1]
    self.position -= 1
    draw
  end

  def keyleft(*)
    return if position.zero?

    self.position -= 1
    print cursor.backward(1)
  end

  def keyright(*)
    return unless position < input.size

    self.position += 1
    print cursor.forward(1)
  end

  def keypress(event)
    kind = Key.new(event).kind

    respond_to?(kind) && send(kind, event) && draw
  end

  def keyenter(*) = app.done!
  def keyreturn(*) = app.done!

  def keyescape(*)
    app.done!
    app.quit!
  end

  def keyctrl_c(*) = keyescape

  def left_word(_event)
    self.position = words.reverse.find { |offset| offset < position }.to_i
  end

  def right_word(_event)
    self.position = words.find { |offset| offset > position } || input.size
  end

  def backspace_word(_event)
    new_position = words.reverse.find { |offset| offset < position }.to_i
    input.slice!(new_position..position)
    self.position = new_position
  end

  def delete_word(_event)
    new_position = words.find { |offset| offset > position } || input.size
    input.slice!(position...new_position)
  end

  def backspace_line(_event)
    input.slice!(0...position)
    self.position = 0
  end

  def regular_char(event)
    input << event.value
    self.position += 1
  end

  private

  attr_reader :cursor, :app, :completions

  def words
    input.to_enum(:scan, /(\b|_)\w/).map do
      Regexp.last_match.offset(0)[0]
    end
  end

  def input_line
    "â¯ #{input} #{cursor.column(3 + position)}"
  end

  def clear_and_restore
    print "#{cursor.save}\r\n#{cursor.clear_screen_down}"
    yield
    print cursor.restore
  end

  def max_rows
    [TTY::Screen.rows - 2, 5].min
  end
end

App.run
